# 数据库记录流程完整说明

## ✅ 是的，数据库会完整记录所有通过二次验证的机会！

---

## 📊 完整记录流程

### 阶段1️⃣: 机会首次发现 (Worker发现)

**触发**: Worker查询发现套利机会

**记录位置**: `packages/jupiter-bot/src/flashloan-bot.ts` Line 879

```typescript
opportunityId = await databaseRecorder.recordOpportunity({
  inputMint: opportunity.inputMint.toBase58(),
  outputMint: opportunity.outputMint.toBase58(),
  bridgeToken: opportunity.bridgeToken,  // "USDC", "USDT" 等
  bridgeMint: opportunity.bridgeMint?.toBase58(),
  inputAmount: BigInt(opportunity.inputAmount),
  outputAmount: BigInt(opportunity.outputAmount),
  bridgeAmount: opportunity.bridgeAmount ? BigInt(opportunity.bridgeAmount) : undefined,
  expectedProfit: firstProfit,  // 首次发现的利润
  expectedRoi: firstRoi,        // 首次发现的ROI
  executed: false,              // 尚未执行
  filtered: false,              // 尚未过滤
  metadata: routeMetadata,      // 🔥 路由详情（包含DEX、跳数等）
});
```

**数据库表**: `Opportunity`

**记录内容**:
- ✅ 输入/输出代币地址
- ✅ 桥接代币（USDC/USDT等）
- ✅ 金额（输入/输出/桥接）
- ✅ 预期利润和ROI
- ✅ 路由元数据（交易路径、DEX信息）
- ✅ 发现时间 (`discoveredAt`)

**日志**:
```
📝 Recorded opportunity #123 with route metadata
```

---

### 阶段2️⃣: 二次验证 (Bot立即验证)

**触发**: 机会发现后立即执行二次验证

**记录位置**: `packages/jupiter-bot/src/flashloan-bot.ts` Line 914

```typescript
await databaseRecorder.recordOpportunityValidation({
  opportunityId,                  // 关联到阶段1的记录
  firstDetectedAt,                // 首次发现时间
  firstProfit,                    // 首次利润
  firstRoi,                       // 首次ROI
  secondCheckedAt: new Date(),    // 二次验证时间
  stillExists: revalidation.stillExists,  // ✅ 是否仍存在
  secondProfit: revalidation.stillExists ? BigInt(revalidation.secondProfit) : undefined,
  secondRoi: revalidation.stillExists ? revalidation.secondRoi : undefined,
  validationDelayMs: revalidation.delayMs,  // 验证延迟
  // 🔥 详细延迟数据
  firstOutboundMs: opportunity.latency?.outboundMs,   // 首次去程延迟
  firstReturnMs: opportunity.latency?.returnMs,       // 首次回程延迟
  secondOutboundMs: revalidation.secondOutboundMs,    // 验证去程延迟
  secondReturnMs: revalidation.secondReturnMs,        // 验证回程延迟
});
```

**数据库表**: `OpportunityValidation`

**记录内容**:
- ✅ 首次和二次的利润对比
- ✅ 首次和二次的ROI对比
- ✅ 验证延迟（总时间）
- ✅ 详细API查询延迟（4个字段）
- ✅ `stillExists` 状态（**这是关键！**）

**日志**:
```
📊 Validation result: stillExists=true, profit=0.000116 SOL (0.00%), delay=172ms
```

---

### 阶段3️⃣: 过滤判断 (如果验证失败或RPC失败)

#### 情况A: 二次验证失败 (stillExists=false)

**触发**: 机会在二次验证时已消失

**记录位置**: `packages/jupiter-bot/src/flashloan-bot.ts` Line 940

```typescript
await databaseRecorder.markOpportunityFiltered(
  opportunityId,
  `Expired on re-validation: profit dropped to ${profit} SOL`
);
```

**更新**: `Opportunity.filtered = true`, `Opportunity.filterReason = "Expired..."`

**日志**:
```
⏱️ Opportunity expired after 172ms, skipping execution
```

#### 情况B: RPC模拟失败 (InsufficientFundsForFee等)

**触发**: 二次验证通过，但RPC模拟失败

**记录位置**: `packages/jupiter-bot/src/flashloan-bot.ts` Line 1091

```typescript
await databaseRecorder.markOpportunityFiltered(
  opportunityId,
  `RPC simulation failed: ${simulation.reason}`
);
```

**更新**: `Opportunity.filtered = true`, `Opportunity.filterReason = "RPC simulation failed..."`

**日志**:
```
❌ Simulation failed (1483ms)
   Reason: InsufficientFundsForFee
   🎉 Saved 0.116 SOL (Gas + Tip) by filtering invalid opportunity
```

---

## 📋 数据库表结构

### 表1: `Opportunity` (机会记录表)

```sql
CREATE TABLE "Opportunity" (
  id BIGSERIAL PRIMARY KEY,
  input_mint TEXT NOT NULL,
  output_mint TEXT NOT NULL,
  bridge_token TEXT,           -- "USDC", "USDT"
  bridge_mint TEXT,
  input_amount BIGINT NOT NULL,
  output_amount BIGINT NOT NULL,
  bridge_amount BIGINT,
  expected_profit BIGINT NOT NULL,  -- 首次发现利润
  expected_roi DOUBLE PRECISION NOT NULL,
  executed BOOLEAN DEFAULT false,
  filtered BOOLEAN DEFAULT false,   -- ✅ 是否被过滤
  filter_reason TEXT,               -- ✅ 过滤原因
  metadata JSONB,                   -- 🔥 路由元数据
  discovered_at TIMESTAMP NOT NULL DEFAULT NOW(),
  -- ... 其他字段
);
```

### 表2: `OpportunityValidation` (验证记录表)

```sql
CREATE TABLE "OpportunityValidation" (
  id BIGSERIAL PRIMARY KEY,
  opportunity_id BIGINT REFERENCES "Opportunity"(id),
  first_detected_at TIMESTAMP NOT NULL,
  first_profit BIGINT NOT NULL,
  first_roi DOUBLE PRECISION NOT NULL,
  second_checked_at TIMESTAMP NOT NULL,
  still_exists BOOLEAN NOT NULL,    -- ✅ 关键字段！
  second_profit BIGINT,
  second_roi DOUBLE PRECISION,
  validation_delay_ms INT NOT NULL,
  -- 🔥 详细延迟数据
  first_outbound_ms INT,
  first_return_ms INT,
  second_outbound_ms INT,
  second_return_ms INT,
  -- ... 其他字段
);
```

---

## 🔍 查询示例

### 查询1: 所有通过二次验证的机会

```sql
SELECT 
  o.id,
  o.bridge_token,
  o.expected_profit / 1000000000.0 AS first_profit_sol,
  v.second_profit / 1000000000.0 AS second_profit_sol,
  v.still_exists,
  v.validation_delay_ms,
  o.filtered,
  o.filter_reason,
  o.discovered_at
FROM "Opportunity" o
JOIN "OpportunityValidation" v ON v.opportunity_id = o.id
WHERE v.still_exists = true  -- ✅ 通过二次验证
ORDER BY o.discovered_at DESC
LIMIT 20;
```

### 查询2: 通过验证但被RPC过滤的机会

```sql
SELECT 
  o.id,
  o.bridge_token,
  v.second_profit / 1000000000.0 AS profit_sol,
  o.filter_reason,
  o.discovered_at
FROM "Opportunity" o
JOIN "OpportunityValidation" v ON v.opportunity_id = o.id
WHERE v.still_exists = true       -- ✅ 通过二次验证
  AND o.filtered = true           -- ⚠️ 但被过滤了
  AND o.filter_reason LIKE '%RPC simulation%'  -- 原因是RPC模拟失败
ORDER BY o.discovered_at DESC;
```

### 查询3: 利润下降统计

```sql
SELECT 
  o.bridge_token,
  COUNT(*) AS total_opportunities,
  AVG((v.second_profit - o.expected_profit)::FLOAT / o.expected_profit * 100) AS avg_profit_change_pct,
  AVG(v.validation_delay_ms) AS avg_validation_delay_ms
FROM "Opportunity" o
JOIN "OpportunityValidation" v ON v.opportunity_id = o.id
WHERE v.still_exists = true
GROUP BY o.bridge_token
ORDER BY total_opportunities DESC;
```

### 查询4: 延迟分析

```sql
SELECT 
  o.id,
  o.bridge_token,
  v.first_outbound_ms + v.first_return_ms AS first_total_ms,
  v.second_outbound_ms + v.second_return_ms AS second_total_ms,
  v.validation_delay_ms,
  v.still_exists
FROM "Opportunity" o
JOIN "OpportunityValidation" v ON v.opportunity_id = o.id
WHERE v.still_exists = true
ORDER BY v.validation_delay_ms ASC
LIMIT 20;
```

---

## 📊 实际案例分析

### 你刚才看到的日志对应的数据库记录

**Opportunity表**:
```
id: 123 (假设)
bridge_token: "USDC"
expected_profit: 2100000 (0.0021 SOL - 首次发现)
expected_roi: 0.0002
filtered: true  ✅
filter_reason: "RPC simulation failed: InsufficientFundsForFee"  ✅
discovered_at: 2025-10-24 03:04:05
```

**OpportunityValidation表**:
```
opportunity_id: 123
still_exists: true  ✅ (关键：说明通过了二次验证)
first_profit: 2100000
second_profit: 116000  (利润下降94.5%)
validation_delay_ms: 172
first_outbound_ms: (从Worker延迟数据)
first_return_ms: (从Worker延迟数据)
second_outbound_ms: (从二次验证数据)
second_return_ms: (从二次验证数据)
```

**解读**:
1. ✅ 机会被记录到 `Opportunity` 表
2. ✅ 二次验证记录到 `OpportunityValidation` 表，`still_exists=true`
3. ✅ RPC模拟失败后，`Opportunity.filtered=true` 被设置
4. ✅ 完整的延迟数据被保存（4个延迟字段）

---

## 🎯 总结

### 数据库会记录什么？

✅ **100%记录**:
- 所有首次发现的机会
- 所有二次验证结果（包括通过和失败）
- 所有延迟数据（首次+二次，去程+回程）
- 所有过滤原因（验证失败、RPC失败等）

✅ **通过二次验证的机会特征**:
- `OpportunityValidation.still_exists = true`
- 有完整的 `second_profit` 和 `second_roi` 数据
- 有完整的延迟分析数据

✅ **被过滤的机会特征**:
- `Opportunity.filtered = true`
- `Opportunity.filter_reason` 说明原因
- 但 `OpportunityValidation` 记录仍然存在（用于统计分析）

### 微信推送 vs 数据库记录

| 机会类型 | 数据库记录 | 微信推送 |
|---------|-----------|---------|
| 首次发现 | ✅ 记录 | ❌ 不推送 |
| 二次验证通过 | ✅ 记录 | ✅ 推送（利润≥0.0001 SOL） |
| 二次验证失败 | ✅ 记录 | ❌ 不推送 |
| RPC模拟失败 | ✅ 记录 | ❌ 不推送（在推送前就被过滤） |

### 查询你的历史记录

```bash
# 连接数据库
psql -U postgres -d postgres

# 查询最近20个通过二次验证的机会
SELECT 
  o.id,
  o.bridge_token,
  o.expected_profit / 1000000000.0 AS first_profit_sol,
  v.second_profit / 1000000000.0 AS second_profit_sol,
  o.filtered,
  o.filter_reason,
  o.discovered_at
FROM "Opportunity" o
JOIN "OpportunityValidation" v ON v.opportunity_id = o.id
WHERE v.still_exists = true
ORDER BY o.discovered_at DESC
LIMIT 20;
```

---

## 📈 数据价值

通过完整的数据库记录，你可以分析：

1. **利润衰减率**: 二次验证后利润平均下降多少%
2. **验证延迟影响**: 延迟与利润下降的关系
3. **代币表现**: 哪个桥接代币的机会更稳定
4. **过滤原因**: 为什么机会被过滤（余额不足、利润消失等）
5. **API延迟**: Ultra API的去程/回程延迟分布
6. **成功率**: 通过验证的机会占比

**你的所有数据都在！** 🎉

